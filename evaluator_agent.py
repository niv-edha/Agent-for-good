import os
import json
import time
import random
from google import genai
from google.genai import types

class EvaluatorAgent:
    def __init__(self):
        # Initialization logic (reads API key and sets self.offline)
        api_key = os.getenv("GEMINI_API_KEY")
        if not api_key:
            self.offline = True
            self.client = None
            self.model = None
        else:
            self.offline = False
            self.client = genai.Client(api_key=api_key)
            self.model = 'gemini-2.5-flash'
        
        self.quiz_schema = types.Schema(
            type=types.Type.OBJECT,
            properties={
                "quiz_title": types.Schema(type=types.Type.STRING, description="A title for the quiz."),
                "questions": types.Schema(
                    type=types.Type.ARRAY,
                    description="A list of 3 to 5 multiple-choice questions based on the lesson.",
                    items=types.Schema(
                        type=types.Type.OBJECT,
                        properties={
                            "question_number": types.Schema(type=types.Type.INTEGER),
                            "question_text": types.Schema(type=types.Type.STRING, description="The text of the question."),
                            "options": types.Schema(type=types.Type.ARRAY, items=types.Schema(type=types.Type.STRING)),
                            "correct_answer": types.Schema(type=types.Type.STRING),
                            "explanation": types.Schema(type=types.Type.STRING),
                        },
                        required=["question_number", "question_text", "options", "correct_answer"]
                    )
                )
            },
            required=["quiz_title", "questions"]
        )

        self.system_prompt = "You are the **Evaluator Agent**. Your task is to generate a quiz as a single, valid JSON object."
        self.grading_system_prompt = "You are the **Evaluator Agent**. Analyze the user's answers and provide a score and personalized feedback."

    def generate_quiz(self, lesson_content: str) -> str:
        print("\n\nðŸ§  Evaluator Agent is generating the quiz...")
        try:
            if self.offline:
                # OFFLINE LOGIC: 10 TOPIC-RELEVANT QUESTIONS BASED ON PLANNER'S GENERIC OUTLINE
                questions = []
                # Extract the dynamic topic from the lesson title generated by the Teacher Agent
                base_topic = lesson_content.splitlines()[0].replace("## OFFLINE LESSON: ", "") if lesson_content.startswith('##') else 'The Topic'
                
                # --- 10 QUESTIONS FOCUSED ON THE GENERIC KEY CONCEPTS ---

                # Q1-Q3: Focus on FUDAMENTALS/INTRO
                questions.append({
                    "question_number": 1, "question_text": f"What is the most fundamental data structure used to model {base_topic}?",
                    "options": ["A complex graph.", "A simple linked list.", "A flat file system."],
                    "correct_answer": "A complex graph.", "explanation": "Most advanced technical concepts rely on a structured, often complex, data model."
                })
                questions.append({
                    "question_number": 2, "question_text": f"The primary purpose of the {base_topic} system is to achieve what outcome?",
                    "options": ["To maximize throughput.", "To achieve security or integrity.", "To reduce energy consumption."],
                    "correct_answer": "To achieve security or integrity.", "explanation": "In advanced computing, integrity and security are key objectives."
                })
                questions.append({
                    "question_number": 3, "question_text": f"In the context of {base_topic}, what term best describes the initial unit of data?",
                    "options": ["Root Node", "Block Header", "Leaf Node"],
                    "correct_answer": "Leaf Node", "explanation": "The smallest unit of data in a hierarchical structure is typically a leaf node."
                })

                # Q4-Q6: Focus on ARCHITECTURE/MECHANISMS
                questions.append({
                    "question_number": 4, "question_text": f"Which technological primitive is essential for the core mechanism of {base_topic}?",
                    "options": ["A specialized hashing function.", "A large language model.", "An IoT sensor network."],
                    "correct_answer": "A specialized hashing function.", "explanation": "Cryptographic security and verification often rely on specialized hashing functions."
                })
                questions.append({
                    "question_number": 5, "question_text": f"The architectural components of {base_topic} typically rely on which operating principle?",
                    "options": ["Synchronous and centralized.", "Asynchronous and sequential.", "Decentralized and peer-to-peer."],
                    "correct_answer": "Decentralized and peer-to-peer.", "explanation": "Many modern security and database architectures rely on distributed ledgers and P2P networks."
                })
                questions.append({
                    "question_number": 6, "question_text": f"The integrity of {base_topic} is confirmed by checking which component?",
                    "options": ["The individual leaf hashes.", "The initial data input.", "The final root signature."],
                    "correct_answer": "The final root signature.", "explanation": "The entire structure's integrity is summarized by and verified against the final root signature."
                })

                # Q7-Q8: Focus on APPLICATIONS
                questions.append({
                    "question_number": 7, "question_text": f"A primary application of {base_topic} involves data within a:",
                    "options": ["Relational Database (SQL).", "Distributed Ledger/Blockchain.", "Simple Spreadsheet."],
                    "correct_answer": "Distributed Ledger/Blockchain.", "explanation": "Distributed ledgers are a common application for integrity verification systems."
                })
                questions.append({
                    "question_number": 8, "question_text": f"In cloud computing, {base_topic} is most often used for what purpose?",
                    "options": ["Managing user access logs.", "Verifying file integrity across storage nodes.", "Optimizing CPU core usage."],
                    "correct_answer": "Verifying file integrity across storage nodes.", "explanation": "Data integrity verification is a critical cloud security application."
                })

                # Q9-Q10: Focus on SECURITY
                questions.append({
                    "question_number": 9, "question_text": f"The security of {base_topic} relies primarily on the hardness of preventing:",
                    "options": ["Factoring large prime numbers.", "Cryptographic collisions.", "Temporary network outages."],
                    "correct_answer": "Cryptographic collisions.", "explanation": "Cryptographic systems rely on the difficulty of finding collisions in the hash function."
                })
                questions.append({
                    "question_number": 10, "question_text": f"If a single data unit in {base_topic} is tampered with, the immediate result is:",
                    "options": ["A localized error that is easily corrected.", "A temporary network slowdown.", "A cascading failure, altering the final signature."],
                    "correct_answer": "A cascading failure, altering the final signature.", "explanation": "The chain of hashes ensures any tamper attempt invalidates the final signature."
                })

                quiz = {"quiz_title": f"{base_topic} - Final Compliance Quiz (10 Questions)", "questions": questions}
                return json.dumps(quiz)

            # Remote flow (runs only in the Kaggle environment)
            contents = [
                types.Content(role="system", parts=[types.Part.from_text(self.system_prompt)]),
                types.Content(role="user", parts=[
                    types.Part.from_text(
                        "Generate the quiz based on the following lesson content. Ensure your response is ONLY the requested JSON object. "
                        f"Lesson Content: {lesson_content}"
                    )
                ])
            ]

            config = types.GenerateContentConfig(
                response_mime_type="application/json",
                response_schema=self.quiz_schema
            )

            response = self._generate_with_retry(model=self.model, contents=contents, config=config)
            return response.text

        except Exception as e:
            return f"An error occurred in the Evaluator Agent: {e}"

    def _generate_with_retry(self, model, contents, config=None, attempts: int = 3, backoff_factor: float = 1.0):
        last_exc = None
        for attempt in range(attempts):
            try:
                return self.client.models.generate_content(model=model, contents=contents, config=config)
            except Exception as e:
                last_exc = e
                if attempt < attempts - 1:
                    sleep_for = backoff_factor * (2 ** attempt) + random.uniform(0, 0.5)
                    time.sleep(sleep_for)
                    continue
                raise last_exc

    def grade_quiz(self, quiz_data: dict, user_answers: dict) -> dict:
        # Local grading logic (always used)
        questions = quiz_data.get("questions", [])
        total = len(questions)
        correct = 0
        details = []
        for q in questions:
            qnum = q.get("question_number")
            correct_answer = q.get("correct_answer")
            user_ans = user_answers.get(qnum)
            is_correct = (user_ans == correct_answer)
            if is_correct:
                correct += 1
            details.append({
                "question_number": qnum,
                "question_text": q.get("question_text"),
                "your_answer": user_ans,
                "correct_answer": correct_answer,
                "is_correct": is_correct,
                "explanation": q.get("explanation")
            })

        score_text = f"{correct}/{total}"
        feedback = {"score": score_text, "total": total, "correct": correct, "details": details}
        return feedback